;; des operations
(define (cookey raw out)
  (define cook (make-vector 32))
  (define (do-cook1 raw0 raw1)
    (bitwise-ior (arithmetic-shift (bitwise-and raw0 #x00fc0000) 6)
		 (arithmetic-shift (bitwise-and raw0 #x00000fc0) 10)
		 (arithmetic-shift (bitwise-and raw1 #x00fc0000) -10)
		 (arithmetic-shift (bitwise-and raw1 #x00000fc0) -6)))
  (define (do-cook2 raw0 raw1)
    (bitwise-ior (arithmetic-shift (bitwise-and raw0 #x0003f000) 12)
		 (arithmetic-shift (bitwise-and raw0 #x0000003f) 16)
		 (arithmetic-shift (bitwise-and raw1 #x0003f000) -4)
		                   (bitwise-and raw1 #x0000003f)))
  (let loop ((index 0))
    (if (= index 32)
	(vector-copy! out 0 cook)
	(let* ((raw0 (vector-ref raw index))
	       (raw1 (vector-ref raw (+ index 1)))
	       (cook1 (do-cook1 raw0 raw1))
	       (cook2 (do-cook2 raw0 raw1)))
	  (vector-set! cook index cook1)
	  (vector-set! cook (+ index 1) cook2)
	  (loop (+ index 2))))))

(define (deskey key key-start dk? out)
  (define kn (make-vector 32 0))
  (define pc1m (make-bytevector 56))
  (define pcr (make-bytevector 56))
  (do ((i 0 (+ i 1)))
      ((= i 56))
    (let* ((l (bytevector-u8-ref PC1 i))
	   (m (bitwise-and l 7))
	   (k3 (bytevector-u8-ref key (+ key-start (arithmetic-shift l -3))))
	   (bm (bytevector-u8-ref BYTEBIT m))
	   (s (if (= (bitwise-and k3 bm) bm) 1 0)))
      (bytevector-u8-set! pc1m i s)))
  (do ((i 0 (+ i 1)))
      ((= i 16) (cookey kn out))
    (let* ((m (if dk? (* (- 15 i) 2) (* i 2)))
	   (n (+ m 1)))
      (vector-set! kn m 0)
      (vector-set! kn n 0)
      (do ((j 0 (+ j 1)))
	  ((= j 28))
	(let ((l (+ j (bytevector-u8-ref TOTROT i))))
	  (if (< l 28)
	      (bytevector-u8-set! pcr j (bytevector-u8-ref pc1m l))
	      (bytevector-u8-set! pcr j (bytevector-u8-ref pc1m (- l 28))))))
      (do ((j 28 (+ j 1)))
	  ((= j 56))
	(let ((l (+ j (bytevector-u8-ref TOTROT i))))
	  (if (< l 56)
	      (bytevector-u8-set! pcr j (bytevector-u8-ref pc1m l))
	      (bytevector-u8-set! pcr j (bytevector-u8-ref pc1m (- l 28))))))
      (do ((j 0 (+ j 1)))
	  ((= j 24))
	(unless (zero? (bytevector-u8-ref pcr (bytevector-u8-ref PC2 j)))
	  (let ((k (vector-ref kn m)))
	    (vector-set! kn m (bitwise-ior k (vector-ref BIGBYTE j)))))
	(unless (zero? (bytevector-u8-ref pcr (bytevector-u8-ref PC2 (+ j 24))))
	  (let ((k (vector-ref kn n)))
	    (vector-set! kn n (bitwise-ior k (vector-ref BIGBYTE j)))))))))

;; desfunc

(define (desfunc block keys)
  (define (ref-2d ip i j) (vector-ref (vector-ref ip i) j))
  (define (des-xor ip left right)
    (let ((tmp (bitwise-xor (ref-2d ip 0 (byte left 0))
			    (ref-2d ip 1 (byte left 1))
			    (ref-2d ip 2 (byte left 2))
			    (ref-2d ip 3 (byte left 3))
			    (ref-2d ip 4 (byte right 0))
			    (ref-2d ip 5 (byte right 1))
			    (ref-2d ip 6 (byte right 2))
			    (ref-2d ip 7 (byte right 3)))))
      (values (bitwise-and #xFFFFFFFF (arithmetic-shift tmp -32))
	      (bitwise-and #xFFFFFFFF tmp))))

  (define (init left right) (des-xor DES-IP left right))

  (define (do-round left right)
    (define (do-xor left right keys ki)
      (let* ((w1 (bitwise-xor (rorc right 4) (vector-ref keys ki)))
	     (l1 (bitwise-xor left 
		  (vector-ref SP7 (bitwise-and w1 #x3f))
		  (vector-ref SP5 (bitwise-and (arithmetic-shift w1 -8)  #x3f))
		  (vector-ref SP3 (bitwise-and (arithmetic-shift w1 -16) #x3f))
		  (vector-ref SP1 (bitwise-and (arithmetic-shift w1 -24) #x3f))))
	     (w2 (bitwise-xor right (vector-ref keys (+ ki 1)))))
	(bitwise-xor l1
	 (vector-ref SP8 (bitwise-and w2 #x3f))
	 (vector-ref SP6 (bitwise-and (arithmetic-shift w2 -8)  #x3f))
	 (vector-ref SP4 (bitwise-and (arithmetic-shift w2 -16) #x3f))
	 (vector-ref SP2 (bitwise-and (arithmetic-shift w2 -24) #x3f)))))

    (let loop ((ki 0) (left left) (right right))
      (if (= ki 32)
	  (values left right)
	  (let* ((left (do-xor left right keys ki))
		 (right (do-xor right left  keys (+ ki 2))))
	    (loop (+ ki 4) left right)))))

  (define (final left right) (des-xor DES-FP left right))

  (let*-values (((left right) (init (vector-ref block 0) (vector-ref block 1)))
		((left right) (do-round left right))
		((left right) (final left right)))
    (vector-set! block 0 right)
    (vector-set! block 1 left)))
